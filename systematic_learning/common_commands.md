## `C`和`C++`文件编译过程 以及对应其分段编译器命令:
### 编译过程 **:**
* **预处理** **:** `头文件展开` , `宏替换` ,  `条件编译` , `去注释`
* **编译** **:** 把 `C` 或 `C++` 语言变成汇编语言
* **汇编** **:** 把 `汇编语言` 变成 `二进制` 目标文件 `->` ( 该 `目标文件` 不是 `可执行` )
* **链接** **:** 将 `目标文件` 和 `库文件` 链接成可执行文件

### 编译器命令 **:**
> 默认以 `gcc` 编译器为例子
#### 默认编译命令 **:**   `gcc [ 文件名 ] -o [ 新可执行文件名 ]` , `-o` **:** 指定输出文件名
#### 分段编译命令 **:**
* **预处理** **:** `gcc -E [ 文件名 ] -o [ 新预处理文件名.i ] `: 在预处理阶段完成后会停下来,生成 `.i` 文件
* **编译** **:**   `gcc -S [ 文件名 ] -o [ 新汇编文件名.s ] ` : 在编译阶段完成后会停下来,生成 `.s` 文件
* **汇编** **:**   `gcc -c [ 汇编文件名.s ] -o [ 新二进制文件名.o ] `: 在汇编阶段完成后会停下来,生成 `.o` 文件
* **链接** **:**   `gcc [ 新二进制文件名.o ] -o [ 新可执行文件名 ] `: 在链接阶段完成后会停下来,生成可执行文件
    ##### 例子 **:** 
    * `gcc -E main.c -o main.i` 
    * `gcc -S main.i -o main.s` 
    * `gcc -c main.s -o main.o` 
    * `gcc main.o -o main`
    > 命令 `[ ESc ]` 对应 `[ iso ]` 文件后缀名
### 静态库编译 **:** 在末尾加上 `-static` 参数,默认编译是动态库编译
## `Linux` 系统常用命令
### 为普通用户添加 `root` 权限
* 需要以 `root` 登录修改系统配置文件 `/etc/sudoers` 文件, 在 `root` 用户后面添加自己的用户名
### `Linux` 缺少 `C` 静态库文件 的解决方法
*  **`centos` 系列安装** **:** 

    ```shell
    sudo yum install glibc-static 
    ``` 
*  **`ubuntu` 系列安装** **:** 

    ```shell
    sudo apt-get install libc6-dev
    ```
    > **注意** **:** 在 `centos` 系列中包管理工具是 `yum` , 在 `ubuntu` 系列中包管理工具是 `apt`
### **`make` 命令**
* **`make` 命令** **:** `make` 命令会根据 `Makefile` 文件中的命令来编译程序, `Makefile` 文件中定义了编译程序所需要的命令和规则, `make` 命令在 `Windows` 中也适用
### `vim` 操作命令 **:** 
> `vim` 进入`命令`模式后，按 `i` 键进入`插入`模式，按 `Esc` 键退出插入模式，`Shift + :`进入`末行`模式 按 `wq` 保存并退出，按 `:q!` 不保存并退出，按 `:q` 退出。
* `vim` 光标命令 **:** 
    * `h` 左移光标
    * `j` 下移光标
    * `k` 上移光标
    * `l` 右移光标
    * `w` 跳转到下一个单词
    * `b` 跳转到上一个单词
    * `Shift + 6` 跳转到行首的第一个非空字符
    * `Shift + 4` 跳转到行尾
    * `Shift + g` 跳转到文件末尾
    * `gg` 跳转到文件开头
    * `n + Shift + g` 跳转到文件第 `n` 行
    * `Ctrl + f` 向下翻页
* `vim` 编辑命令 **:**
    * `dd` 删除光标所在行
    * `ndd` 删除光标所在行及其下n行
    * `u` 撤销
    * `Ctrl + r` 恢复撤销
    * `yy` 复制光标所在行
    * `nyy` 复制光标所在行及其下n行
    * `p` 粘贴
    * `np` 粘贴n次
    * `x` 删除光标所在字符
    * `nx` 删除光标所在字符及其后n个字符
*  `vim` 文件操作命令 **:**
    * `:w` 保存
    * `:q` 退出
    * `:wq` 保存并退出
    * `:q!` 不保存并退出
    * `:wq!` 强制保存并退出
### `git` 命令 **:**
* `git clone` 克隆远程仓库
* `git add [ 文件名 ]` 添加文件到 `git` 仓库
* `git commit -m [ 提交信息 ]` 提交文件到 `git` 仓库
* `git status` 查看当前 `git` 仓库的状态
* `git log` 查看当前 `git` 仓库的提交历史
* `git rm` 删除文件
* `git push` 推送文件到远程仓库
* `git pull` 拉取远程仓库的文件
### 进程理解 **:**
* #### 进程状态 **:**
    * **运行** **:** `R(running)` 进程正在运行，在进程队列上;
    * **睡眠** **:** `S(sleeping)` 可中断睡眠状态，进程因等待某个事件（比如 `I/O` 完成、信号触发）而暂停，可被信号唤醒;
    * **等待** **:** `D(disk sleep)` 不可中断睡眠状态，多因等待磁盘 `I/O` 等关键操作，无法被信号打断;
    * **暂停** **:** `T(stopped)` 进程被停止运行，等待信号;
    * **暂停** **:** `t(tracing stop)` 因调试（如 `ptrace` 跟踪）暂停的状态，和普通 `T` 类似，但由调试器触发,表示这个进程正在被追踪;
    * **僵尸** **:** `Z(zombie)` 进程已经结束，但是其父进程还没有回收其资源;
    * **死亡** **:** `X(dead)` 进程被杀掉或结束;
* #### 查看进程信息命令 **:** 
    * `ps ajx` 查看所有进程信息
    * `top` 查看当前进程信息
    * `htop` 查看当前进程信息
    * `pstree` 查看进程树
    * `ps -ef` 查看所有进程信息
    * `ps -aux` 查看所有进程信息
    * `ps -ef | grep [ 进程名 ]` 查看指定进程信息
  > 如果显示的是如 `R+` `S+` 说明这是前台进程，，不带加则是后台进程
* #### 进程信号
    * **`SIGINT`  2**  **:** 中断进程;
    * **`SIGQUIT` 3**  **:** 退出进程;
    * **`SIGKILL` 9**  **:** 杀死进程;
    * **`SIGTERM` 15** **:** 终止进程;
    * **`SIGCONT` 18** **:** 继续进程;
    * **`SIGSTOP` 19** **:** 停止进程;
    * **`SIGTSTP` 20** **:** 暂停进程;

* #### `kill` 命令 **:**
    * `kill  -信号 [ 进程ID ]` 对进程做更改
### 环境变量 **:**
* #### 查看环境变量命令 **:**
    * `env` **:** 查看所有环境变量；
    * `echo` **:** 查看某一环境变量
    * `export` **:** 设置一个新的环境变量
    * `set` **:** 显示本地定义的环境变量和`shell`变量
    * `unser` **:** 清除环境变量
    ```shell
    env     #显示当前所有环境变量
    echo $NAME      #显示NAME环境变量
    MY_USER=wang      #定义一个本地变量
    export MY_NAME="泥嚎"     #设置一个MY_NAME的环境变量
    set     #显示本地定义的shell和环境变量
    unset MY_NAME     #删除定义的MY_NAME变量
    ```
    > 本地变量不能被子进程继承,对于 `echo` 这是一个子进程，再`export`定义一个新的本地变量，为么能访问本地变量？
* #### 系统调用 **:**
    * `char* env[]`
    * `getenv()`
    * `extern char** environ`